\chapter{Etude de faisabilité}

\section{Utilisation de la LibSL -- prototype d'un premier bot}
\subsection{Présentation}
Afin de mieux comprendre les principes de la LibSL et voir les possibilités de celle-ci, nous avons effectué quelques tests simples d'utilisation de cette librairie. 

Pour se faire, un bot a été créé à l'aide de tutoriaux disponibles sur le site officiel de la LibSL \footnote{LibSL : \url{http://www.libsecondlife.org/wiki/Main_Page}}. D'un autre côté, nous avons visualisé concrètement notre bot à l'aide d'un compte joueur.
\subsection{Code}
Voici le code d'un bot de base :
\begin{code}
class MyFirstBot
{
    public static SecondLife client = new SecondLife();

    private static string first_name = "***";
    private static string last_name = "***";
    private static string password = "****";

    public static void Main()
    {
        string startLocation = NetworkManager.StartLocation("Gaia", 192, 42, 100);
        client.Network.OnConnected +=
        new NetworkManager.ConnectedCallback(Network_OnConnected);
            
        if (client.Network.Login(first_name, last_name, password,
        "My First Bot",startLocation, "Your name"))
        {
            Console.WriteLine("I logged into Second Life!");
        }
        else
        {
            Console.WriteLine("I couldn't log in, here is why: " +
            client.Network.LoginMessage);
        }
    }

    static void Network_OnConnected(object sender)
    {
        Console.WriteLine("Now I am going to logout of SL.. Goodbye!");
        client.Network.Logout();
    }
}
\end{code}

\subsubsection{Explications}
 Tout d'abord, la première chose à faire est de créer une instance de l'objet SecondLife. 
 Celui-ci permet de gérer le côté client de \SL. Ce client permet l'interaction avec le serveur \SL sans passer par une application graphique. 
 C'est pour cette raison qu'en parallèle, nous avons joué avec un avatar classique afin visualiser notre bot. 

Le package $NetworkManager$ permet de gérer l'aspect connexion au serveur \SL. Ainsi dans cet exemple, nous avons pu préciser la localisation de départ de notre bot. Ensuite il faut rajouter des évènements aux différents type de controller du client. Ici, nous avons rajouté un évènement quand notre bot sera connecté, la fonction :
\begin{code}
static void NetworkOnConnected(object sender) 
\end{code}
sera alors exécuté. Ici, notre bot se déconnecte aussitôt.

Cette ligne permet d'effectuer la connexion du bot au serveur : 
\begin{code}
client.Network.Login(firstname,lastname, password, "My First Bot",startLocation, "Your name")
\end{code}
 Si celle-ci se déroule correctement, alors l'évènement décrit au-dessus sera exécuté. 

\subsection{Les intéractions du bot avec un avatar}
\subsubsection{Code}
\begin{code}
.....
client.Self.OnInstantMessage += new AgentManager.InstantMessageCallback(Self_OnInstantMessage);
            client.Self.OnChat += new AgentManager.ChatCallback(Self_OnChat); 
.....

  static void Self_OnInstantMessage(InstantMessage im, Simulator sim)
        {
            switch (im.Dialog)
            {
                case InstantMessageDialog.FriendshipOffered:
                	// Accept Friendship Offer
                    client.Friends.AcceptFriendship(im.FromAgentID, im.IMSessionID);
                    // Decline Friendship Offer
                    //client.Friends.DeclineFriendship(im.FromAgentID, im.IMSessionID); 
                    break;
                case InstantMessageDialog.GroupInvitation:
                    WearOutFit("Girl Next Door Avatar Polka Dress Top - Pink");
                    // Accept Group Invitation (Join Group)
                    client.Self.InstantMessage(client.Self.Name,im.FromAgentID, 
                    		string.Empty, im.IMSessionID,
                        	InstantMessageDialog.GroupInvitationAccept, 
                        	InstantMessageOnline.Offline, client.Self.SimPosition,
                        	LLUUID.Zero, new byte[0]);

                    /* Decline Group Invitation
                     * client.Self.InstantMessage(client.Self.Name, 
                     *          im.FromAgentID, string.Empty, im.IMSessionID, 
                     *          InstantMessageDialog.GroupInvitationDecline, 
                     *          InstantMessageOnline.Offline, client.Self.SimPosition, 
                     *          LLUUID.Zero, new byte[0]); */
                    break;
                    
                case InstantMessageDialog.InventoryOffered:
                    // Accept Inventory Offer
                    client.Self.InstantMessage(client.Self.Name, im.FromAgentID, 
                            String.Empty, im.IMSessionID,
                            InstantMessageDialog.InventoryAccepted, 
                            InstantMessageOnline.Offline, client.Self.SimPosition,
                            LLUUID.Zero, new byte[0]);

                    /* Decline Inventory Offer
                     * Client.Self.InstantMessage(client.Self.Name, im.FromAgentID, 
                     *         string.Empty, im.IMSessionID,
                     *         InstantMessageDialog.InventoryDeclined, 
                     *         InstantMessageOnline.Offline, client.Self.SimPosition,
                     *         LLUUID.Zero, new byte[0]);  */
                    break;

                // someone sent a teleport lure
                case InstantMessageDialog.RequestTeleport:
                    client.Self.TeleportLureRespond(im.FromAgentID, true);
                    break;

                default:
                    break;
            }

        }
        static void Network_OnConnected(object sender)
        {
            Console.WriteLine("Hello");
            LLUUID target = new LLUUID("be94a7d6-4b67-4e67-b237-31caece8e133");

            client.Self.InstantMessage(target, "hello !");
            client.Self.Chat("Hello World!", 0, ChatType.Normal);
        }
\end{code}
\subsubsection{Explications}
Comme avec l'exemple précédent, il faut ajouter des évènements à notre bot pour que celui réagisse à un message instantané d'un avatar
\begin{code}
client.Self.OnInstantMessage += new AgentManager.InstantMessageCallback(Self_OnInstantMessage)
\end{code}
Cette ligne permet de signifier à notre bot que lorsqu'il reçoit un message instantané, il devra exécuter la fonction $Self\_OnInstantMessage$.

Dans cette fonction, on peut voir un panel des possibilités offertes à notre bot en termes de relationnel avec un avatar. Quelques exemples:
\begin{code}
case InstantMessageDialog.FriendshipOffered:
                    client.Friends.AcceptFriendship(im.FromAgentID, im.IMSessionID);
\end{code}
Notre bot acceptera automatiquement une demande pour être rajouté sur une liste d'amis. 


\begin{code}
client.Self.InstantMessage(client.Self.Name, im.FromAgentID, 
                        string.Empty, im.IMSessionID,
                        InstantMessageDialog.GroupInvitationAccept, 
                        InstantMessageOnline.Offline, client.Self.SimPosition,
                        LLUUID.Zero, new byte[0]); 
\end{code}
De même, notre bot accepte automatiquement, une demande de participation à un groupe. 


\begin{code}
case InstantMessageDialog.RequestTeleport:
                    client.Self.TeleportLureRespond(im.FromAgentID, true);
\end{code}
Cette ligne est très intéressante pour notre projet, en effet, cela permet à notre bot d'être téléporté à côté d'un avatar. Cette facilité de déplacement aidera grandement notre bot à rejoindre un individu qui serait susceptible de lui fournir des renseignements.

\subsection{Résultats}
Avec ces simples tests, on a pu se rendre compte des possibilités qu'offrait la libSL. Cela nous a permis de voir qu'un bot peut être créé très facilement. Le fait que nous jouions un compte joueur au côté du bot, nous a servis à mieux appréhender les tests. Nous avons ainsi pu le voir dans le jeu et bien s'assurer qu'il agissait comme nous le voulions. En réalisant ces tests, nous avons rencontré un seul soucis. L'avatar du bot ne se charge pas. A la place, il apparaissait sous forme d'un halo de fumée. En interrogeant d'autres joueurs, ces derniers ont répondu que cela venait d'un problème de chargement de l'apparence de notre personnage. Mais même en laissant tourner le jeu durant quelques dizaines de minutes, celui-ci n'apparaissait toujours pas. Il faudra durant l'implémentation de notre bot se soucier de ce problème. Cela ne gène en rien les interactions avec le monde de \SL mais cela nuit au côté humain de notre bot. 

\section{Utilisation de l'API Google -- recherche de mots lis}
\subsection{Présentation}
Google a mis à disposition une API permettant de gérer la plupart des services proposés par Google sur le Web(recherches , gestion de mails, gestion de calendriers, \ldots)

Nous utiliserons donc la partie permettant de faire des recherches sur le Web. 

\subsection{Code}
\begin{code}
static void Main(string[] args)
{

    string keyWord = "avions";

    StreamWriter monStreamWriter = new StreamWriter("testRequeteSur"+ keyWord +".html");
    //Objet communicant avec Google
    Google.GData.Client.Service monService = new Service("MonAppliDeRecherche");

    Uri monUri = new Uri("http://www.google.fr/search?q=" + keyWord);

    //FeedQuery fQ = new FeedQuery("http://www.google.fr/search?q=avions");
    //Mise en place du "timer"
    DateTime before = DateTime.Now;
    StreamReader stReader = new StreamReader(monService.Query(monUri));
        
    while (!stReader.EndOfStream)
    {

        //Console.WriteLine(tmp.ReadLine());
        monStreamWriter.WriteLine(stReader.ReadLine());

    }
    //Calcul du temps passé
    Console.WriteLine("Temps d'exécution => " + DateTime.Now - before);
    Console.Read();

    monStreamWriter.Close();
    stReader.Close();
}
\end{code}

\subsection{Explications}
L'objet qui nous permet de faire des requêtes Google est ici un objet de type Service. Nous avons utilisé un constructeur prenant en paramètre une chaîne de caractère qui, à titre indicatif, nommera notre application (cette chaîne de caractères n'a aucune influence sur le comportement de l'objet). 

\begin{code}
Google.GData.Client.Service monService = new Service("MonAppliDeRecherche");
\end{code}
Ensuite nous créons un objet de type URI qui est un objet appartenant à la bibliothèque C\# et qui ''permet la représentation d'une ressource sur internet''~\footnote{URI \url{http://msdn.microsoft.com/en-us/library/system.uri(VS.71).aspx}}

Nous passons donc une adresse mail qui sera utilisé par l'objet $monService$ afin d'exécuter la requête. Cela peut paraître étrange de passer l'adresse de Google avec l'argument de recherche à l'objet de la classe Service, mais l'implémentation de requête a été voulue comme cela par les développeurs de l'API \footnote{API Google : \url{http://code.google.com/intl/fr/apis/gdata/docs/2.0/reference.html#Queries}}

Un appel à :

\begin{code}
monService.Query(monUri);
\end{code}

retourne un objet de type $Stream$ contenant le code source de la page qui référence les 10 premiers résultats de cette recherche. 

\subsection{Tests de performance}
Nous avons effectué plusieurs recherches sur des mots clés de longueur et de spécificité variable, globalement, le temps de recherche est quasiment le même : environ 0.5 secondes. Ce temps comprend l'exécution du code qui lance la requête. Bien sûr lorsque nous ferons un traitement de ces données, le temps d'exécution sera plus long, mais cela n'influencera pas le temps mis par Google pour faire ses recherches. (Mots rentrés : bus, avions à réaction, les fonctions vitales communes à homme et au chimpanzé). 

\subsection{Problèmes}
L'API Google nous permet d'utiliser un objet spécifique de type $AtomFeed?$ qui ordonne les résultats en mémoire, mais pour l'instant nous n'arrivons pas encore à bien l'utiliser. La documentation est peu fournie et les exemples ne sont pas non plus très nombreux.

\section{Questsin -- thesaurus API}
Pour remédier au problème rencontré avec l'API Google, nous avons cherché d'autres moyens de récupérer des mots liés à un autre. Cette mise en relation de mots est appelée thesaurus, l'un des plus utilisé sur le net est celui proposé par Questsin. On peut voir quelques exemples en ligne de son utilisation, notamment sur le site ''Pipes'' \footnote{Pipes : \url{http://pipes.yahoo.com/pipes}}. Voici les tests que nous avons effectués sur cette API :
\begin{itemize}
	\item test de validité des réponses données par le serveur ;
	\item test du temps total pour récupérer une liste de mot à partir d'un mot clé ;
	\item test : le nombre de mot récupéré est bien celui attendu ; 
\end{itemize}

\subsection{Code}
On lance les recherches dans un nouveau thread (pour que le bot puisse faire autre chose en attendant la réponse du serveur)
\begin{code}
   Thread mythread = new Thread(new ThreadStart(threadLoop));
   mythread.Start(); 
\end{code}


Le code exécuté par le thread, c'est lui qui fait les tests :
\begin{code}
/** Thread qui fait la recherche de mot liés à un mot 
  * clé et calcul le temps total de recherche */
public void threadLoop()
{
    // Liste de mot clés pour le test de temps de réponse
    string[] keywords = {"bot","second","life","used","earn","money","value"
                         ,"land","build","objects","drugs","monkey","elephant","bush"
                         ,"freedom","hat","human","nature","real","virtual"};

    // , tests éffectués sur une demande de 10 puis 20 
    // puis 40 et enfin 80 mots liés au mot clé
    int nbresponses = 10;
    int nbtests = 6;

    // Utilisé pour le calcul du temps moyen d'un requête 
    // sur la totalité des tests
    TimeSpan verytotal = new TimeSpan(0,0,0,0,0);
    int totalsize = 0;

    for (int i = 1; i <= nbtests; i++)
    {
        // Lance le chrono
        DateTime begin = DateTime.Now;

        // On récupère les mots clés dans un tableau 
        // (mais on ne les conserve pas)
        List<string> result = new List<string>();
        foreach (string keyword in keywords)
            result = GetRelatedWords(keyword, nbresponses);

        // Arrete le chrono et affiche le temps 
        // total et moyen d'execution
        DateTime end = DateTime.Now;
        TimeSpan exetime = end - begin;
           
        // Calcul pour le total final 
        verytotal += exetime;
        totalsize += keywords.Length;

        Console.WriteLine("Pour "+result.Count+"/"+nbresponses+" 
                           mots liés, temps total(moyen) des requetes : "
                           + exetime.ToString() + "(" 
                           + (exetime.TotalSeconds / keywords.Length) 
                           + " secondes)");

        // Le test suivant sur 2 fois plus de réponses 
        nbresponses *= 2;
    }

   Console.WriteLine("Tests terminés, temps moyen d'une requête : "
                      + (verytotal.TotalSeconds / totalsize ));
}
\end{code}
\pagebreak


La fonction qui permet de récupérer une liste de mots liés à partir d'un mot :
\begin{code}
private List<string> GetRelatedWords (string keyword, int nbresponses)
{
  try
  {
       // Les mots liés au mot clé passé en paramètre seront stocké dans result
       List<string> result = new List<string>();

       // Récupération de la réponse à la requête (GET) suivante
       HttpWebResponse hresp = HttpGet("http://fillbug.com/rss.asp?"+
            "q="+keyword+"&N="+nbresponses);
    
       // Si on à bien réqupéré la réponse (pas de 404, 503, ...) 
       if (hresp.StatusCode.ToString() == "OK") //hresp.StatusCode == 200
       {
            // Transformation de la réponse format texte vers XML (sorte de cast) :
            Stream s = hresp.GetResponseStream();
            XmlReader reader = XmlReader.Create(s);

            // Lecture du flux XML
            reader.MoveToContent();
            // Recherche des "item" :
            while (reader.ReadToFollowing("item"))
            {
               // Récupère la valeur de title
               result.Add(GetPropertyValue(reader.ReadSubtree(), "title")); 
            }
       }
       return result;
  }
  catch 
  {
       return null;
  }
}
\end{code}



La fonction qui retourne la réponse renvoyée par la requête 'URI' (GET) :
\begin{code}
private HttpWebResponse HttpGet(string URI)
{
    HttpWebRequest hreq = (HttpWebRequest)HttpWebRequest.Create(URI);
    // temps maximum accepté pour obtenir un "retour" (5 sec)
    hreq.Timeout = 5000;
    return (HttpWebResponse)hreq.GetResponse();
}
\end{code}



La fonction retourne la valeur de la propriété 'property' dans le flux XML 'reader' :
\begin{code}
static string GetPropertyValue(XmlReader reader, string property)
{
    reader.ReadToFollowing(property);
    return reader.ReadElementContentAsString(property, reader.NamespaceURI);
}
\end{code}


\subsection{Résultats des tests}

Voici les résultats obtenus, pour des test sur 20 mots clés, en cherchant successivement pour chacun d'entre eux 10, 20, 40, 80, 160 et enfin 320 mots liés

\begin{code}
Pour 10/10 mots liés, temps total(moyen) des requêtes : 00:00:42.500(2,125 secondes)
Pour 20/20 mots liés, temps total(moyen) des requêtes : 00:00:52.093(2,604 secondes)
Pour 40/40 mots liés, temps total(moyen) des requêtes : 00:00:54.903(2,7451 secondes)
Pour 80/80 mots liés, temps total(moyen) des requêtes : 00:00:48.455(2,422 secondes)
Pour 160/160 mots liés, temps total(moyen) des requêtes : 00:00:51.187(2,559 secondes)
Pour 320/320 mots liés, temps total(moyen) des requêtes : 00:01:00.500(3,0250 secondes)

Tests terminés, temps moyen d'une requête : 2,580 secondes
\end{code}

\noindent Remarques :
\begin{itemize}
	\item pour chaque requête, on a bien obtenu le nombre de résultats demandés ;
	\item les temps d'exécution comprennent l'insertion dans un tableau des données récupérées ;
	\item es temps d'exécution pouvant être allongés, les tests ayant été effectués depuis une machine virtuelle (vboxxp). Cependant, dans l'optique d'une utilisation lors d'une conversation, ces temps sont corrects relativement au temps de réponse d'un joueur humain ; 
\end{itemize}